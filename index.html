<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Vector Visualizer - Export/Import</title> <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/DragControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #controls { position: absolute; top: 10px; left: 10px; background-color: rgba(40, 40, 40, 0.9); padding: 15px; border-radius: 8px; color: white; width: 300px; max-height: calc(100vh - 20px); overflow-y: auto; box-shadow: 0 4px 8px rgba(0,0,0,0.3); scrollbar-width: thin; scrollbar-color: #555 #333; }
        #controls::-webkit-scrollbar { width: 8px; } #controls::-webkit-scrollbar-track { background: #333; border-radius: 4px; } #controls::-webkit-scrollbar-thumb { background-color: #555; border-radius: 4px; border: 2px solid #333; }
        #controls h2, #controls h3 { border-bottom: 1px solid #555; padding-bottom: 5px; margin-bottom: 10px; }
        #controls label { display: block; margin-bottom: 8px; width: 100%; box-sizing: border-box; font-size: 0.9em; }
        #controls input[type="number"], #controls select, #controls input[type="text"] { padding: 8px; border: 1px solid #555; background-color: #333; color: white; border-radius: 4px; display: block; width: 100%; box-sizing: border-box; margin-bottom: 8px;}
        #controls select { appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;utf8,<svg fill="white" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>'); background-repeat: no-repeat; background-position: right 8px center; background-size: 16px; padding-right: 30px; }
        #controls input[type="number"] { -moz-appearance: textfield; } #controls input[type="number"]::-webkit-outer-spin-button, #controls input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        #controls input[type="color"] { height: 38px; padding: 2px; border: 1px solid #555; border-radius: 4px; background-color: #333; display: block; width: 100%; box-sizing: border-box; margin-bottom: 8px;}
        #controls button { padding: 10px; background-color: #4a90e2; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s ease; margin-top: 5px; display: block; width: 100%; box-sizing: border-box; font-size: 0.9em; }
        #controls button:hover:not(:disabled) { background-color: #357abd; } #controls button:disabled { background-color: #555; cursor: not-allowed; }
        #vectorList { margin-top: 15px; max-height: 150px; overflow-y: auto; font-size: 0.9em; scrollbar-width: thin; scrollbar-color: #555 #333; }
        #vectorList::-webkit-scrollbar { width: 6px; } #vectorList::-webkit-scrollbar-track { background: #333; border-radius: 3px;} #vectorList::-webkit-scrollbar-thumb { background-color: #555; border-radius: 3px; border: 1px solid #333; }
        .vector-list-item { padding: 6px 2px; border-bottom: 1px solid #555; display: flex; justify-content: space-between; align-items: center; } .vector-list-item:last-child { border-bottom: none; }
        .vector-item-details { display: flex; align-items: center; flex-grow: 1; margin-right: 8px; overflow: hidden; white-space: nowrap; }
        .vector-color-swatch { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 6px; flex-shrink: 0; }
        .vector-coords { text-overflow: ellipsis; overflow: hidden; }
        .vector-actions { display: flex; align-items: center; flex-shrink: 0; }
        .vector-action-btn { background: none; border: none; padding: 3px 5px; cursor: pointer; border-radius: 4px; margin-left: 4px; display: flex; align-items: center; justify-content: center; }
        .vector-action-btn svg { width: 14px; height: 14px; } .vector-action-btn.edit-vector-btn { color: #60a5fa; } .vector-action-btn.edit-vector-btn:hover { background-color: rgba(96, 165, 250, 0.2); color: #3b82f6; }
        .vector-action-btn.remove-vector-btn { color: #f87171; } .vector-action-btn.remove-vector-btn:hover { background-color: rgba(248, 113, 113, 0.2); color: #ef4444; }
        #operationsSection, #sceneOptionsSection, #ioSection { margin-top: 20px; padding-top: 15px; border-top: 1px solid #555; }
        .op-group { margin-bottom: 15px; padding: 10px; background-color: rgba(255, 255, 255, 0.05); border-radius: 6px; } .op-group label { font-size: 0.9em; margin-bottom: 4px; }
        #operationResult { margin-top: 15px; padding: 10px; background-color: #2a3a4a; border-radius: 4px; min-height: 30px; font-size: 0.9em; word-wrap: break-word; }
        .result-success { color: #4ade80; } .result-error { color: #f87171; } .result-warning { color: #fbbf24; } .result-info { color: #60a5fa; }
        canvas.draggable-hover { cursor: grab; } canvas.dragging { cursor: grabbing; }
        .vector-dependency-info { font-size: 0.8em; color: #a0aec0; margin-left: 4px; }
        .op-info { font-size: 0.85em; color: #cbd5e0; margin-top: 8px; padding-top: 8px; border-top: 1px dashed #555; }
        .op-info span { display: block; margin-bottom: 3px; } .op-info code { color: #ecc94b; font-family: monospace;}
        .toggle-label { display: flex; align-items: center; font-size: 0.9em; cursor: pointer; margin-bottom: 6px; }
        .toggle-label input[type="checkbox"] { margin-right: 8px; width: auto; margin-bottom: 0; accent-color: #4a90e2; cursor: pointer; }
        .op-button-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 12px; }
        .io-buttons { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }

    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-800">

    <div id="scene-container"></div>

    <div id="controls">
        <h2 class="text-lg font-semibold" id="vectorFormTitle">Add Vector</h2>
        <input type="hidden" id="editingVectorId" value="">
        <label for="vec-x">X:</label> <input type="number" id="vec-x" value="1" step="0.1">
        <label for="vec-y">Y:</label> <input type="number" id="vec-y" value="1" step="0.1">
        <label for="vec-z">Z:</label> <input type="number" id="vec-z" value="1" step="0.1">
        <label for="vec-color">Color:</label> <input type="color" id="vec-color" value="#ff0000">
        <button id="add-update-vector-btn">Add Vector</button>
        <button id="cancel-edit-btn" class="hidden mt-1 !bg-gray-500 hover:!bg-gray-600">Cancel Edit</button>
        <div id="sceneOptionsSection"> <h3 class="text-md font-semibold">Scene Options</h3> <label class="toggle-label"> <input type="checkbox" id="toggleAxes" checked> Show Axes </label> <label class="toggle-label"> <input type="checkbox" id="toggleGrid" checked> Show Grid </label> </div>
        <div id="vectorList" class="mt-4"> <h3 class="text-md font-semibold">Vectors</h3> <p class="text-gray-400 text-sm p-2">No vectors added yet.</p> </div>
        <div id="operationsSection"> <h2 class="text-lg font-semibold">Operations</h2> <div class="op-group"> <label for="opVectorA">Vector A:</label> <select id="opVectorA"></select> <label for="opVectorB">Vector B:</label> <select id="opVectorB"></select> <div id="opInfoDisplay" class="op-info"> <span>|A|: <code id="magnitudeA">-</code></span> <span>|B|: <code id="magnitudeB">-</code></span> <span>Angle(A, B): <code id="angleAB">-</code></span> </div> <div class="op-button-grid"> <button id="add-btn">Add (A+B)</button> <button id="sub-btn">Subtract (A-B)</button> <button id="dot-btn">Dot (A·B)</button> <button id="cross-btn">Cross (AxB)</button> </div> <button id="proj-btn" class="mt-2">Project (A onto B)</button> </div> <div class="op-group"> <label for="scalarVector">Vector:</label> <select id="scalarVector"></select> <label for="scalarValue">Scalar:</label> <input type="number" id="scalarValue" value="2" step="0.1"> <button id="scalar-mult-btn">Scalar Multiply</button> </div> <h3 class="text-md font-semibold mt-4">Result</h3> <div id="operationResult">Select an operation...</div> </div>
        <div id="ioSection">
            <h2 class="text-lg font-semibold">Import / Export</h2>
            <div class="io-buttons">
                 <button id="import-scene-btn">Import Scene (.json)</button>
                 <button id="export-scene-btn">Export Scene (.json)</button>
            </div>
            <input type="file" id="importFile" accept=".json" style="display: none;"> </div>
    </div>

    <script>
        let scene, camera, renderer, orbitControls, dragControls;
        let axesHelper, gridHelper;
        const vectors = []; const draggableObjects = []; const sceneContainer = document.getElementById('scene-container');

        const vectorListDiv = document.getElementById('vectorList'); const operationResultDiv = document.getElementById('operationResult');
        const opVectorASelect = document.getElementById('opVectorA'); const opVectorBSelect = document.getElementById('opVectorB'); const scalarVectorSelect = document.getElementById('scalarVector');
        const addBtn = document.getElementById('add-btn'); const subBtn = document.getElementById('sub-btn'); const dotBtn = document.getElementById('dot-btn'); const crossBtn = document.getElementById('cross-btn'); const scalarMultBtn = document.getElementById('scalar-mult-btn'); const projBtn = document.getElementById('proj-btn');
        const vectorFormTitle = document.getElementById('vectorFormTitle'); const editingVectorIdInput = document.getElementById('editingVectorId');
        const vecXInput = document.getElementById('vec-x'); const vecYInput = document.getElementById('vec-y'); const vecZInput = document.getElementById('vec-z'); const vecColorInput = document.getElementById('vec-color');
        const addUpdateBtn = document.getElementById('add-update-vector-btn'); const cancelEditBtn = document.getElementById('cancel-edit-btn');
        const scalarValueInput = document.getElementById('scalarValue');
        const magnitudeADisplay = document.getElementById('magnitudeA'); const magnitudeBDisplay = document.getElementById('magnitudeB'); const angleABDisplay = document.getElementById('angleAB');
        const toggleAxesCheckbox = document.getElementById('toggleAxes'); const toggleGridCheckbox = document.getElementById('toggleGrid');
        const importSceneBtn = document.getElementById('import-scene-btn'); const exportSceneBtn = document.getElementById('export-scene-btn'); const importFileInput = document.getElementById('importFile');

        const HANDLE_SIZE = 0.2; const PROJECTION_COLOR = '#FFA500';

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x2d3748); camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(5, 5, 5); camera.lookAt(scene.position); renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); sceneContainer.appendChild(renderer.domElement); const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(5, 10, 7.5); scene.add(directionalLight); orbitControls = new THREE.OrbitControls(camera, renderer.domElement); orbitControls.enableDamping = true; orbitControls.dampingFactor = 0.05; orbitControls.screenSpacePanning = false; orbitControls.minDistance = 1; orbitControls.maxDistance = 100; orbitControls.maxPolarAngle = Math.PI; axesHelper = new THREE.AxesHelper(5); scene.add(axesHelper); gridHelper = new THREE.GridHelper(10, 10); scene.add(gridHelper); axesHelper.visible = toggleAxesCheckbox.checked; gridHelper.visible = toggleGridCheckbox.checked; dragControls = new THREE.DragControls(draggableObjects, camera, renderer.domElement); dragControls.addEventListener('dragstart', onDragStart); dragControls.addEventListener('drag', onDrag); dragControls.addEventListener('dragend', onDragEnd); dragControls.addEventListener('hoveron', onHoverOn); dragControls.addEventListener('hoveroff', onHoverOff); window.addEventListener('resize', onWindowResize, false); addUpdateBtn.addEventListener('click', handleAddOrUpdateVector); cancelEditBtn.addEventListener('click', cancelEditMode); addBtn.addEventListener('click', performVectorAddition); subBtn.addEventListener('click', performVectorSubtraction); dotBtn.addEventListener('click', performDotProduct); crossBtn.addEventListener('click', performCrossProduct); scalarMultBtn.addEventListener('click', performScalarMultiplication); projBtn.addEventListener('click', performProjection); opVectorASelect.addEventListener('change', updateMagnitudeAngleDisplay); opVectorBSelect.addEventListener('change', updateMagnitudeAngleDisplay); toggleAxesCheckbox.addEventListener('change', () => { if (axesHelper) axesHelper.visible = toggleAxesCheckbox.checked; }); toggleGridCheckbox.addEventListener('change', () => { if (gridHelper) gridHelper.visible = toggleGridCheckbox.checked; }); exportSceneBtn.addEventListener('click', exportScene); importSceneBtn.addEventListener('click', () => importFileInput.click()); importFileInput.addEventListener('change', importScene); updateVectorListUI(); animate();
        }

        // --- Core Function ---

        function generateVectorName(baseName = "V", existingNames = []) {  let counter = existingNames.length + 1; let newName = `${baseName}${counter}`; while (existingNames.includes(newName)) { counter++; newName = `${baseName}${counter}`; } return newName; }
        function handleAddOrUpdateVector() {  const editingId = parseFloat(editingVectorIdInput.value); if (!isNaN(editingId)) { updateVector(editingId); } else { addVectorFromInput(); } }
        function addVectorFromInput() {  try { const x = parseFloat(vecXInput.value); const y = parseFloat(vecYInput.value); const z = parseFloat(vecZInput.value); const color = vecColorInput.value; if (isNaN(x) || isNaN(y) || isNaN(z)) { showResult("Error: Invalid vector coordinates.", "error"); return; } const direction = new THREE.Vector3(x, y, z); if (direction.lengthSq() < 1e-10) { showResult("Warning: Cannot add zero-length vector.", "warning"); return; } const origin = new THREE.Vector3(0, 0, 0); const name = generateVectorName("V", vectors.map(v => v.name)); const definition = { type: 'base' }; addVectorToScene(origin, direction, color, name, definition, false, null, true); showResult(`Added vector ${name}: (${x}, ${y}, ${z})`, "success"); resetVectorForm(); } catch (error) { console.error("Error adding vector:", error); showResult("Error adding vector. See console.", "error"); } }
        function updateVector(id) { const vectorIndex = vectors.findIndex(v => v.id === id); if (vectorIndex === -1) { showResult(`Error: Vector ID ${id} not found.`, "error"); cancelEditMode(); return; } try { const x = parseFloat(vecXInput.value); const y = parseFloat(vecYInput.value); const z = parseFloat(vecZInput.value); const color = vecColorInput.value; if (isNaN(x) || isNaN(y) || isNaN(z)) { showResult("Error: Invalid coordinates.", "error"); return; } const newDirection = new THREE.Vector3(x, y, z); if (newDirection.lengthSq() < 1e-10) { showResult("Warning: Cannot update to zero-length vector.", "warning"); return; } const vectorData = vectors[vectorIndex]; if (vectorData.definition.type !== 'base') { console.log(`Vector ${vectorData.name} converted to base vector due to form edit.`); vectorData.definition = { type: 'base' }; vectorData.isResult = false; showResult(`Warning: Vector ${vectorData.name} is now a base vector (form edit broke dependency).`, "warning"); } const updateSuccess = updateVectorProperties(vectorData, newDirection, color); if (updateSuccess) { updateDependentVectors(id); updateVectorListUI(); showResult(`Updated vector ${vectorData.name}.`, "success"); } cancelEditMode(); } catch (error) { console.error("Error updating vector:", error); showResult("Error updating vector. See console.", "error"); } }
        function updateVectorProperties(vectorData, newDirection, newColor) {  const arrow = vectorData.arrow; const handle = vectorData.dragHandle; const newLength = newDirection.length(); if (newLength < 1e-5) { console.warn("Attempted near-zero length for", vectorData.name); if (handle && dragControls.object && dragControls.object === handle) { handle.position.copy(vectorData.direction); } return false; } arrow.setDirection(newDirection.clone().normalize()); const headLength = Math.min(newLength * 0.2, 0.5); const headWidth = Math.min(newLength * 0.1, 0.3); arrow.setLength(newLength, headLength, headWidth); if (newColor && vectorData.color !== newColor) { arrow.setColor(new THREE.Color(newColor).getHex()); vectorData.color = newColor; } vectorData.direction.copy(newDirection); if (handle) { handle.position.copy(newDirection); } return true; }


        function addVectorToScene(origin, direction, color, name, definition, isResult = false, existingId = null, updateUI = true) { 
            const length = direction.length();
            if (length < 1e-10 && existingId === null) { console.warn(`Skipping zero-length vector: ${name}`); return null; }

            const hexColor = new THREE.Color(color).getHex();
            const dirNormalized = length > 1e-10 ? direction.clone().normalize() : new THREE.Vector3(1, 0, 0);
            const headLength = Math.min(length * 0.2, 0.5); const headWidth = Math.min(length * 0.1, 0.3);
            const arrowHelper = new THREE.ArrowHelper(dirNormalized, origin, length, hexColor, headLength, headWidth); scene.add(arrowHelper);
            const handleGeometry = new THREE.SphereGeometry(HANDLE_SIZE, 8, 8); const handleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.0, depthTest: false });
            const dragHandle = new THREE.Mesh(handleGeometry, handleMaterial); dragHandle.position.copy(direction); scene.add(dragHandle);

            const vectorData = {
                id: existingId !== null ? existingId : Date.now() + Math.random(), origin: origin.clone(), direction: direction.clone(), color: color, name: name, arrow: arrowHelper, dragHandle: dragHandle, definition: definition, isResult: isResult || definition.type === 'operation'
            };
            vectors.push(vectorData);
            dragHandle.userData.vectorId = vectorData.id; draggableObjects.push(dragHandle);

            if (updateUI) {
                updateVectorListUI();
            }
            console.log("Added vector:", vectorData);
            return vectorData;
        }


        function findVectorById(id) { return vectors.find(v => v.id === id) || null; }
        function updateDependentVectors(changedVectorId, visited = new Set()) { if (visited.has(changedVectorId)) { return; } visited.add(changedVectorId); console.log("Updating dependents of:", changedVectorId); vectors.forEach(dependentVector => { if (dependentVector.definition?.type === 'operation') { const opInfo = dependentVector.definition; let needsUpdate = false; let operandValues = []; if (opInfo.operands.includes(changedVectorId)) { needsUpdate = true; operandValues = opInfo.operands.map(id => findVectorById(id)); if (operandValues.some(v => v === null)) { console.warn(`Operand missing for ${dependentVector.name}. Converting to base.`); dependentVector.definition = { type: 'base' }; dependentVector.isResult = false; needsUpdate = false; } } if (needsUpdate) { console.log(`Recalculating ${dependentVector.name} based on ${changedVectorId}`); let newDirection = new THREE.Vector3(); let calculationSuccess = true; try { switch (opInfo.op) { case 'add': newDirection.addVectors(operandValues[0].direction, operandValues[1].direction); break; case 'sub': newDirection.subVectors(operandValues[0].direction, operandValues[1].direction); break; case 'cross': newDirection.crossVectors(operandValues[0].direction, operandValues[1].direction); break; case 'scalar_mult': const scalar = opInfo.scalar ?? 1; newDirection.copy(operandValues[0].direction).multiplyScalar(scalar); break; case 'projection': const vecA = operandValues[0].direction; const vecB = operandValues[1].direction; const lenBSq = vecB.lengthSq(); if (lenBSq > 1e-10) { const dotProduct = vecA.dot(vecB); const scalarProjection = dotProduct / lenBSq; newDirection.copy(vecB).multiplyScalar(scalarProjection); } else { newDirection.set(0, 0, 0); } break; default: console.error("Unknown operation type:", opInfo.op); calculationSuccess = false; } } catch (error) { console.error(`Error recalculating ${dependentVector.name}:`, error); calculationSuccess = false; dependentVector.definition = { type: 'base' }; dependentVector.isResult = false; } if (calculationSuccess) { const updateOk = updateVectorProperties(dependentVector, newDirection); if (updateOk) { updateDependentVectors(dependentVector.id, visited); } } } } }); }

        // --- Delete ---
        function updateVectorListUI() { vectorListDiv.innerHTML = '<h3 class="text-md font-semibold mb-1">Vectors</h3>'; opVectorASelect.innerHTML = ''; opVectorBSelect.innerHTML = ''; scalarVectorSelect.innerHTML = ''; const editIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg>`; const trashIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" /></svg>`; if (vectors.length === 0) { vectorListDiv.innerHTML += '<p class="text-gray-400 text-sm p-2">No vectors added yet.</p>'; const placeholderOption = '<option value="" disabled>No vectors</option>'; opVectorASelect.innerHTML = placeholderOption; opVectorBSelect.innerHTML = placeholderOption; scalarVectorSelect.innerHTML = placeholderOption; } else { vectors.forEach(vec => { const div = document.createElement('div'); div.className = 'vector-list-item'; const vecCoords = `(${vec.direction.x.toFixed(1)}, ${vec.direction.y.toFixed(1)}, ${vec.direction.z.toFixed(1)})`; let dependencyInfo = ''; if (vec.definition?.type === 'operation') { const op = vec.definition.op; const operandNames = vec.definition.operands.map(id => findVectorById(id)?.name || '?'); if (op === 'scalar_mult') { dependencyInfo = `(${vec.definition.scalar} * ${operandNames[0]})`; } else if (op === 'projection') { dependencyInfo = `(Proj_${operandNames[1]}(${operandNames[0]}))`; } else { dependencyInfo = `(${operandNames[0]} ${opSymbol(op)} ${operandNames[1]})`; } } const isEditable = vec.definition?.type === 'base'; const editButtonHtml = `<button data-id="${vec.id}" class="vector-action-btn edit-vector-btn ${!isEditable ? 'opacity-50 cursor-not-allowed' : ''}" title="${isEditable ? 'Edit Vector' : 'Cannot edit dependent vector'}" ${!isEditable ? 'disabled' : ''}>${editIconSVG}</button>`; div.innerHTML = `<span class="vector-item-details"><span class="vector-color-swatch" style="background-color:${vec.color};"></span><span class="font-semibold mr-1">${vec.name}:</span><span class="vector-coords">${vecCoords}</span><span class="vector-dependency-info">${dependencyInfo}</span></span><span class="vector-actions">${editButtonHtml}<button data-id="${vec.id}" class="vector-action-btn remove-vector-btn" title="Remove Vector">${trashIconSVG}</button></span>`; if (isEditable) { div.querySelector('.edit-vector-btn').addEventListener('click', () => startEditVector(vec.id)); } div.querySelector('.remove-vector-btn').addEventListener('click', () => removeVectorById(vec.id)); vectorListDiv.appendChild(div); const option = document.createElement('option'); option.value = vec.id; option.textContent = `${vec.name} ${vecCoords}`; opVectorASelect.appendChild(option.cloneNode(true)); opVectorBSelect.appendChild(option.cloneNode(true)); scalarVectorSelect.appendChild(option.cloneNode(true)); }); if (opVectorBSelect.options.length > 1) { opVectorBSelect.selectedIndex = 1; } } updateMagnitudeAngleDisplay(); updateOperationButtonStates(); }
        function updateMagnitudeAngleDisplay() { const vecAData = getSelectedVectorData('opVectorA'); const vecBData = getSelectedVectorData('opVectorB'); if (vecAData) { magnitudeADisplay.textContent = vecAData.direction.length().toFixed(3); } else { magnitudeADisplay.textContent = "-"; } if (vecBData) { magnitudeBDisplay.textContent = vecBData.direction.length().toFixed(3); } else { magnitudeBDisplay.textContent = "-"; } if (vecAData && vecBData) { const lenA = vecAData.direction.lengthSq(); const lenB = vecBData.direction.lengthSq(); if (lenA < 1e-10 || lenB < 1e-10) { angleABDisplay.textContent = "N/A (Zero Vector)"; } else { const angleRad = vecAData.direction.angleTo(vecBData.direction); const angleDeg = angleRad * (180 / Math.PI); angleABDisplay.textContent = `${angleDeg.toFixed(1)}°`; } } else { angleABDisplay.textContent = "-"; } }
        function opSymbol(opName) { switch(opName) { case 'add': return '+'; case 'sub': return '-'; case 'cross': return 'x'; default: return '?'; } }
        function updateOperationButtonStates() { const vecCount = vectors.length; addBtn.disabled = vecCount < 2; subBtn.disabled = vecCount < 2; dotBtn.disabled = vecCount < 2; crossBtn.disabled = vecCount < 2; scalarMultBtn.disabled = vecCount < 1; projBtn.disabled = vecCount < 2; }
        function disposeVectorAssets(vectorData) { if (!vectorData) return; const arrow = vectorData.arrow; if (arrow) { if (arrow.line && arrow.line.geometry) arrow.line.geometry.dispose(); if (arrow.line && arrow.line.material) arrow.line.material.dispose(); if (arrow.cone && arrow.cone.geometry) arrow.cone.geometry.dispose(); if (arrow.cone && arrow.cone.material) arrow.cone.material.dispose(); } const handle = vectorData.dragHandle; if (handle) { if (handle.geometry) handle.geometry.dispose(); if (handle.material) handle.material.dispose(); } }
        function removeVectorById(id) { const indexToRemove = vectors.findIndex(vec => vec.id === id); if (indexToRemove !== -1) { const vectorToRemove = vectors[indexToRemove]; const removedName = vectorToRemove.name; const dependentsToConvert = []; vectors.forEach(v => { if (v.definition?.type === 'operation' && v.definition.operands.includes(id)) { dependentsToConvert.push(v); } }); dependentsToConvert.forEach(dep => { console.log(`Converting ${dep.name} to base vector because ${removedName} was deleted.`); dep.definition = { type: 'base' }; dep.isResult = false; showResult(`Vector ${dep.name} is now a base vector (dependency ${removedName} removed).`, "warning"); }); const handleIndex = draggableObjects.indexOf(vectorToRemove.dragHandle); if (handleIndex > -1) { draggableObjects.splice(handleIndex, 1); } else { console.warn("Drag handle not found in draggableObjects for vector:", removedName); } scene.remove(vectorToRemove.arrow); scene.remove(vectorToRemove.dragHandle); disposeVectorAssets(vectorToRemove); vectors.splice(indexToRemove, 1); updateVectorListUI(); showResult(`Removed vector ${removedName}.`, "info"); console.log("Removed vector with ID:", id); if (parseFloat(editingVectorIdInput.value) === id) { cancelEditMode(); } } else { console.warn("Could not find vector ID to remove:", id); } }
        function getSelectedVectorData(selectElementId) { const selectElement = document.getElementById(selectElementId); const selectedId = parseFloat(selectElement.value); if (isNaN(selectedId)) return null; return vectors.find(vec => vec.id === selectedId) || null; }
        function showResult(message, type = 'info') { operationResultDiv.textContent = message; operationResultDiv.className = `result-${type} mt-4 p-2 bg-gray-700 rounded min-h-[30px] text-sm word-wrap`; }
        function startEditVector(id) { const vectorData = vectors.find(vec => vec.id === id); if (!vectorData || vectorData.definition?.type !== 'base') { console.error("Cannot edit: Vector not found or is dependent.", id); showResult("Error: Cannot edit dependent vectors via form.", "error"); return; } console.log("Starting edit for vector ID:", id, vectorData.name); vectorFormTitle.textContent = `Edit Vector ${vectorData.name}`; editingVectorIdInput.value = id; vecXInput.value = vectorData.direction.x.toFixed(3); vecYInput.value = vectorData.direction.y.toFixed(3); vecZInput.value = vectorData.direction.z.toFixed(3); vecColorInput.value = vectorData.color; addUpdateBtn.textContent = 'Update Vector'; cancelEditBtn.classList.remove('hidden'); showResult(`Editing base vector ${vectorData.name}. Modify values or drag arrowhead.`, "info"); }
        function cancelEditMode() { vectorFormTitle.textContent = 'Add Vector'; editingVectorIdInput.value = ''; resetVectorForm(); addUpdateBtn.textContent = 'Add Vector'; cancelEditBtn.classList.add('hidden'); }
        function resetVectorForm() { vecXInput.value = '1'; vecYInput.value = '1'; vecZInput.value = '1'; vecColorInput.value = '#ff0000'; }
        function onDragStart(event) { const handle = event.object; console.log("Drag Start Handle for:", handle.userData.vectorId); orbitControls.enabled = false; handle.material.opacity = 0.5; renderer.domElement.classList.add('dragging'); }
        function onDrag(event) { const draggedHandle = event.object; const vectorId = draggedHandle.userData.vectorId; if (vectorId === undefined) return; const vectorData = findVectorById(vectorId); if (!vectorData) return; if (vectorData.definition.type !== 'base') { console.log(`Vector ${vectorData.name} converted to base vector due to drag.`); vectorData.definition = { type: 'base' }; vectorData.isResult = false; } const newDirection = draggedHandle.position; const updateSuccess = updateVectorProperties(vectorData, newDirection); if (updateSuccess) { updateDependentVectors(vectorId, new Set()); const listItem = vectorListDiv.querySelector(`button[data-id="${vectorId}"]`)?.closest('.vector-list-item'); if (listItem) { const coordsSpan = listItem.querySelector('.vector-coords'); if (coordsSpan) { coordsSpan.textContent = `(${newDirection.x.toFixed(1)}, ${newDirection.y.toFixed(1)}, ${newDirection.z.toFixed(1)})`; } const optionText = `${vectorData.name} (${newDirection.x.toFixed(1)}, ${newDirection.y.toFixed(1)}, ${newDirection.z.toFixed(1)})`; [opVectorASelect, opVectorBSelect, scalarVectorSelect].forEach(select => { const option = select.querySelector(`option[value="${vectorId}"]`); if (option) option.textContent = optionText; }); } if (parseFloat(editingVectorIdInput.value) === vectorId) { vecXInput.value = newDirection.x.toFixed(3); vecYInput.value = newDirection.y.toFixed(3); vecZInput.value = newDirection.z.toFixed(3); } } }
        function onDragEnd(event) { const handle = event.object; const vectorId = handle.userData.vectorId; console.log("Drag End Handle for:", vectorId); orbitControls.enabled = true; handle.material.opacity = 0.0; renderer.domElement.classList.remove('dragging'); if (vectorId === undefined) return; const vectorData = findVectorById(vectorId); if (!vectorData) return; updateVectorListUI(); showResult(`Vector ${vectorData.name} updated via drag.`, "info"); }
        function onHoverOn(event) { renderer.domElement.classList.add('draggable-hover'); } function onHoverOff(event) { renderer.domElement.classList.remove('draggable-hover'); }

        // --- Vector Operations ---
        function performVectorAddition() { const vecAData = getSelectedVectorData('opVectorA'); const vecBData = getSelectedVectorData('opVectorB'); if (!vecAData || !vecBData) { showResult("Error: Select two vectors.", "error"); return; } const resultVec = new THREE.Vector3().addVectors(vecAData.direction, vecBData.direction); const resultName = generateVectorName(`${vecAData.name}+${vecBData.name}`, vectors.map(v => v.name)); const definition = { type: 'operation', op: 'add', operands: [vecAData.id, vecBData.id] }; const newVecData = addVectorToScene(new THREE.Vector3(0,0,0), resultVec, '#FFFFFF', resultName, definition, false, null, true); if (newVecData) showResult(`Add: ${resultName} = (${resultVec.x.toFixed(2)}, ${resultVec.y.toFixed(2)}, ${resultVec.z.toFixed(2)})`, "success"); }
        function performVectorSubtraction() { const vecAData = getSelectedVectorData('opVectorA'); const vecBData = getSelectedVectorData('opVectorB'); if (!vecAData || !vecBData) { showResult("Error: Select two vectors.", "error"); return; } const resultVec = new THREE.Vector3().subVectors(vecAData.direction, vecBData.direction); const resultName = generateVectorName(`${vecAData.name}-${vecBData.name}`, vectors.map(v => v.name)); const definition = { type: 'operation', op: 'sub', operands: [vecAData.id, vecBData.id] }; const newVecData = addVectorToScene(new THREE.Vector3(0,0,0), resultVec, '#FFFF00', resultName, definition, false, null, true); if (newVecData) showResult(`Sub: ${resultName} = (${resultVec.x.toFixed(2)}, ${resultVec.y.toFixed(2)}, ${resultVec.z.toFixed(2)})`, "success"); }
        function performScalarMultiplication() { const vecData = getSelectedVectorData('scalarVector'); const scalar = parseFloat(scalarValueInput.value); if (!vecData) { showResult("Error: Select a vector.", "error"); return; } if (isNaN(scalar)) { showResult("Error: Invalid scalar.", "error"); return; } const resultVec = vecData.direction.clone().multiplyScalar(scalar); const resultName = generateVectorName(`${scalar}*${vecData.name}`, vectors.map(v => v.name)); const definition = { type: 'operation', op: 'scalar_mult', operands: [vecData.id], scalar: scalar }; const newVecData = addVectorToScene(new THREE.Vector3(0,0,0), resultVec, '#00FFFF', resultName, definition, false, null, true); if (newVecData) showResult(`Scalar Mult: ${resultName} = (${resultVec.x.toFixed(2)}, ${resultVec.y.toFixed(2)}, ${resultVec.z.toFixed(2)})`, "success"); }
        function performDotProduct() { const vecAData = getSelectedVectorData('opVectorA'); const vecBData = getSelectedVectorData('opVectorB'); if (!vecAData || !vecBData) { showResult("Error: Select two vectors.", "error"); return; } const dotProduct = vecAData.direction.dot(vecBData.direction); showResult(`Dot Product (${vecAData.name} · ${vecBData.name}) = ${dotProduct.toFixed(3)}`, "info"); }
        function performCrossProduct() { const vecAData = getSelectedVectorData('opVectorA'); const vecBData = getSelectedVectorData('opVectorB'); if (!vecAData || !vecBData) { showResult("Error: Select two vectors.", "error"); return; } const resultVec = new THREE.Vector3().crossVectors(vecAData.direction, vecBData.direction); const resultName = generateVectorName(`${vecAData.name}x${vecBData.name}`, vectors.map(v => v.name)); if (resultVec.lengthSq() < 1e-10) { showResult(`Cross Product (${vecAData.name} x ${vecBData.name}) = 0 (Vectors parallel)`, "warning"); } else { const definition = { type: 'operation', op: 'cross', operands: [vecAData.id, vecBData.id] }; const newVecData = addVectorToScene(new THREE.Vector3(0,0,0), resultVec, '#FF00FF', resultName, definition, false, null, true); if (newVecData) showResult(`Cross Product: ${resultName} = (${resultVec.x.toFixed(2)}, ${resultVec.y.toFixed(2)}, ${resultVec.z.toFixed(2)})`, "success"); } }
        function performProjection() { const vecAData = getSelectedVectorData('opVectorA'); const vecBData = getSelectedVectorData('opVectorB'); if (!vecAData || !vecBData) { showResult("Error: Select two vectors for projection.", "error"); return; } const vecA = vecAData.direction; const vecB = vecBData.direction; const lenBSq = vecB.lengthSq(); let projectionVector = new THREE.Vector3(); if (lenBSq > 1e-10) { const dotProduct = vecA.dot(vecB); const scalarProjection = dotProduct / lenBSq; projectionVector.copy(vecB).multiplyScalar(scalarProjection); } else { showResult(`Cannot project onto zero vector (${vecBData.name}). Result is zero vector.`, "warning"); } const resultName = generateVectorName(`Proj_${vecBData.name}(${vecAData.name})`, vectors.map(v => v.name)); const definition = { type: 'operation', op: 'projection', operands: [vecAData.id, vecBData.id] }; const newVecData = addVectorToScene( new THREE.Vector3(0, 0, 0), projectionVector, PROJECTION_COLOR, resultName, definition, false, null, true ); if (newVecData) { showResult(`Projection ${resultName} = (${projectionVector.x.toFixed(2)}, ${projectionVector.y.toFixed(2)}, ${projectionVector.z.toFixed(2)})`, "success"); } else if (lenBSq <= 1e-10) { } else { showResult(`Projection ${resultName} resulted in a zero vector.`, "info"); } }

        // --- Import/Export Functions --
        function clearScene() { while (vectors.length > 0) { const vectorData = vectors.pop(); if (vectorData.arrow) scene.remove(vectorData.arrow); if (vectorData.dragHandle) scene.remove(vectorData.dragHandle); disposeVectorAssets(vectorData); } draggableObjects.length = 0; updateVectorListUI(); showResult("Scene cleared.", "info"); }
        function prepareDataForExport() { return vectors.map(vec => ({ id: vec.id, name: vec.name, color: vec.color, origin: { x: vec.origin.x, y: vec.origin.y, z: vec.origin.z }, direction: { x: vec.direction.x, y: vec.direction.y, z: vec.direction.z }, definition: vec.definition })); }
        function exportScene() { try { const exportData = prepareDataForExport(); if (exportData.length === 0) { showResult("Scene is empty, nothing to export.", "warning"); return; } const jsonString = JSON.stringify(exportData, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'vector_scene.json'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); showResult("Scene exported successfully.", "success"); } catch (error) { console.error("Error exporting scene:", error); showResult("Error exporting scene. See console for details.", "error"); } }
        function importScene(event) { const file = event.target.files[0]; if (!file) { showResult("No file selected for import.", "info"); return; } const reader = new FileReader(); reader.onload = (e) => { try { const importedData = JSON.parse(e.target.result); if (!Array.isArray(importedData)) { throw new Error("Invalid file format: Expected an array of vectors."); } clearScene(); let importCount = 0; importedData.forEach(vecData => { if (vecData && typeof vecData.direction === 'object' && typeof vecData.definition === 'object') { const origin = new THREE.Vector3(vecData.origin?.x || 0, vecData.origin?.y || 0, vecData.origin?.z || 0); const direction = new THREE.Vector3(vecData.direction.x || 0, vecData.direction.y || 0, vecData.direction.z || 0); const color = vecData.color || '#ffffff'; const name = vecData.name || 'ImportedVector'; const definition = vecData.definition; const id = vecData.id; addVectorToScene(origin, direction, color, name, definition, false, id, false); importCount++; } else { console.warn("Skipping invalid vector data during import:", vecData); } }); updateVectorListUI();  showResult(`Successfully imported ${importCount} vectors.`, "success"); } catch (error) { console.error("Error importing scene:", error); showResult(`Error importing scene: ${error.message}`, "error"); clearScene(); } finally { importFileInput.value = null; } }; reader.onerror = (e) => { console.error("Error reading file:", e); showResult("Error reading import file.", "error"); importFileInput.value = null; }; reader.readAsText(file); }

        // --- Event Handlers ---
        function onWindowResize() {  camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function animate() {  requestAnimationFrame(animate); orbitControls.update(); renderer.render(scene, camera); }

        init();

    </script>

</body>
</html>
