let scene, camera, renderer, orbitControls, dragControls;
let axesHelper, gridHelper;
const vectors = []; const draggableObjects = []; const sceneContainer = document.getElementById('scene-container');

const vectorListDiv = document.getElementById('vectorList'); const operationResultDiv = document.getElementById('operationResult');
const opVectorASelect = document.getElementById('opVectorA'); const opVectorBSelect = document.getElementById('opVectorB'); const scalarVectorSelect = document.getElementById('scalarVector');
const addBtn = document.getElementById('add-btn'); const subBtn = document.getElementById('sub-btn'); const dotBtn = document.getElementById('dot-btn'); const crossBtn = document.getElementById('cross-btn'); const scalarMultBtn = document.getElementById('scalar-mult-btn'); const projBtn = document.getElementById('proj-btn');
const vectorFormTitle = document.getElementById('vectorFormTitle'); const editingVectorIdInput = document.getElementById('editingVectorId');
const vecXInput = document.getElementById('vec-x'); const vecYInput = document.getElementById('vec-y'); const vecZInput = document.getElementById('vec-z'); const vecColorInput = document.getElementById('vec-color');
const addUpdateBtn = document.getElementById('add-update-vector-btn'); const cancelEditBtn = document.getElementById('cancel-edit-btn');
const scalarValueInput = document.getElementById('scalarValue');
const magnitudeADisplay = document.getElementById('magnitudeA'); const magnitudeBDisplay = document.getElementById('magnitudeB'); const angleABDisplay = document.getElementById('angleAB');
const toggleAxesCheckbox = document.getElementById('toggleAxes'); const toggleGridCheckbox = document.getElementById('toggleGrid');
const importSceneBtn = document.getElementById('import-scene-btn'); const exportSceneBtn = document.getElementById('export-scene-btn'); const importFileInput = document.getElementById('importFile');

const HANDLE_SIZE = 0.2; const PROJECTION_COLOR = '#FFA500';

function init() {
    scene = new THREE.Scene(); scene.background = new THREE.Color(0x2d3748); camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(5, 5, 5); camera.lookAt(scene.position); renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); sceneContainer.appendChild(renderer.domElement); const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(5, 10, 7.5); scene.add(directionalLight); orbitControls = new THREE.OrbitControls(camera, renderer.domElement); orbitControls.enableDamping = true; orbitControls.dampingFactor = 0.05; orbitControls.screenSpacePanning = false; orbitControls.minDistance = 1; orbitControls.maxDistance = 100; orbitControls.maxPolarAngle = Math.PI; axesHelper = new THREE.AxesHelper(5); scene.add(axesHelper); gridHelper = new THREE.GridHelper(10, 10); scene.add(gridHelper); axesHelper.visible = toggleAxesCheckbox.checked; gridHelper.visible = toggleGridCheckbox.checked; dragControls = new THREE.DragControls(draggableObjects, camera, renderer.domElement); dragControls.addEventListener('dragstart', onDragStart); dragControls.addEventListener('drag', onDrag); dragControls.addEventListener('dragend', onDragEnd); dragControls.addEventListener('hoveron', onHoverOn); dragControls.addEventListener('hoveroff', onHoverOff); window.addEventListener('resize', onWindowResize, false); addUpdateBtn.addEventListener('click', handleAddOrUpdateVector); cancelEditBtn.addEventListener('click', cancelEditMode); addBtn.addEventListener('click', performVectorAddition); subBtn.addEventListener('click', performVectorSubtraction); dotBtn.addEventListener('click', performDotProduct); crossBtn.addEventListener('click', performCrossProduct); scalarMultBtn.addEventListener('click', performScalarMultiplication); projBtn.addEventListener('click', performProjection); opVectorASelect.addEventListener('change', updateMagnitudeAngleDisplay); opVectorBSelect.addEventListener('change', updateMagnitudeAngleDisplay); toggleAxesCheckbox.addEventListener('change', () => { if (axesHelper) axesHelper.visible = toggleAxesCheckbox.checked; }); toggleGridCheckbox.addEventListener('change', () => { if (gridHelper) gridHelper.visible = toggleGridCheckbox.checked; }); exportSceneBtn.addEventListener('click', exportScene); importSceneBtn.addEventListener('click', () => importFileInput.click()); importFileInput.addEventListener('change', importScene); updateVectorListUI(); animate();
}

// --- Core Function ---

function generateVectorName(baseName = "V", existingNames = []) {  let counter = existingNames.length + 1; let newName = `${baseName}${counter}`; while (existingNames.includes(newName)) { counter++; newName = `${baseName}${counter}`; } return newName; }
function handleAddOrUpdateVector() {  const editingId = parseFloat(editingVectorIdInput.value); if (!isNaN(editingId)) { updateVector(editingId); } else { addVectorFromInput(); } }
function addVectorFromInput() {  try { const x = parseFloat(vecXInput.value); const y = parseFloat(vecYInput.value); const z = parseFloat(vecZInput.value); const color = vecColorInput.value; if (isNaN(x) || isNaN(y) || isNaN(z)) { showResult("Error: Invalid vector coordinates.", "error"); return; } const direction = new THREE.Vector3(x, y, z); if (direction.lengthSq() < 1e-10) { showResult("Warning: Cannot add zero-length vector.", "warning"); return; } const origin = new THREE.Vector3(0, 0, 0); const name = generateVectorName("V", vectors.map(v => v.name)); const definition = { type: 'base' }; addVectorToScene(origin, direction, color, name, definition, false, null, true); showResult(`Added vector ${name}: (${x}, ${y}, ${z})`, "success"); resetVectorForm(); } catch (error) { console.error("Error adding vector:", error); showResult("Error adding vector. See console.", "error"); } }
function updateVector(id) { const vectorIndex = vectors.findIndex(v => v.id === id); if (vectorIndex === -1) { showResult(`Error: Vector ID ${id} not found.`, "error"); cancelEditMode(); return; } try { const x = parseFloat(vecXInput.value); const y = parseFloat(vecYInput.value); const z = parseFloat(vecZInput.value); const color = vecColorInput.value; if (isNaN(x) || isNaN(y) || isNaN(z)) { showResult("Error: Invalid coordinates.", "error"); return; } const newDirection = new THREE.Vector3(x, y, z); if (newDirection.lengthSq() < 1e-10) { showResult("Warning: Cannot update to zero-length vector.", "warning"); return; } const vectorData = vectors[vectorIndex]; if (vectorData.definition.type !== 'base') { console.log(`Vector ${vectorData.name} converted to base vector due to form edit.`); vectorData.definition = { type: 'base' }; vectorData.isResult = false; showResult(`Warning: Vector ${vectorData.name} is now a base vector (form edit broke dependency).`, "warning"); } const updateSuccess = updateVectorProperties(vectorData, newDirection, color); if (updateSuccess) { updateDependentVectors(id); updateVectorListUI(); showResult(`Updated vector ${vectorData.name}.`, "success"); } cancelEditMode(); } catch (error) { console.error("Error updating vector:", error); showResult("Error updating vector. See console.", "error"); } }
function updateVectorProperties(vectorData, newDirection, newColor) {  const arrow = vectorData.arrow; const handle = vectorData.dragHandle; const newLength = newDirection.length(); if (newLength < 1e-5) { console.warn("Attempted near-zero length for", vectorData.name); if (handle && dragControls.object && dragControls.object === handle) { handle.position.copy(vectorData.direction); } return false; } arrow.setDirection(newDirection.clone().normalize()); const headLength = Math.min(newLength * 0.2, 0.5); const headWidth = Math.min(newLength * 0.1, 0.3); arrow.setLength(newLength, headLength, headWidth); if (newColor && vectorData.color !== newColor) { arrow.setColor(new THREE.Color(newColor).getHex()); vectorData.color = newColor; } vectorData.direction.copy(newDirection); if (handle) { handle.position.copy(newDirection); } return true; }


function addVectorToScene(origin, direction, color, name, definition, isResult = false, existingId = null, updateUI = true) {
    const length = direction.length();
    if (length < 1e-10 && existingId === null) { console.warn(`Skipping zero-length vector: ${name}`); return null; }

    const hexColor = new THREE.Color(color).getHex();
    const dirNormalized = length > 1e-10 ? direction.clone().normalize() : new THREE.Vector3(1, 0, 0);
    const headLength = Math.min(length * 0.2, 0.5); const headWidth = Math.min(length * 0.1, 0.3);
    const arrowHelper = new THREE.ArrowHelper(dirNormalized, origin, length, hexColor, headLength, headWidth); scene.add(arrowHelper);
    const handleGeometry = new THREE.SphereGeometry(HANDLE_SIZE, 8, 8); const handleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.0, depthTest: false });
    const dragHandle = new THREE.Mesh(handleGeometry, handleMaterial); dragHandle.position.copy(direction); scene.add(dragHandle);

    const vectorData = {
        id: existingId !== null ? existingId : Date.now() + Math.random(), origin: origin.clone(), direction: direction.clone(), color: color, name: name, arrow: arrowHelper, dragHandle: dragHandle, definition: definition, isResult: isResult || definition.type === 'operation'
    };
    vectors.push(vectorData);
    dragHandle.userData.vectorId = vectorData.id; draggableObjects.push(dragHandle);

    if (updateUI) {
        updateVectorListUI();
    }
    console.log("Added vector:", vectorData);
    return vectorData;
}


function findVectorById(id) { return vectors.find(v => v.id === id) || null; }
function updateDependentVectors(changedVectorId, visited = new Set()) { if (visited.has(changedVectorId)) { return; } visited.add(changedVectorId); console.log("Updating dependents of:", changedVectorId); vectors.forEach(dependentVector => { if (dependentVector.definition?.type === 'operation') { const opInfo = dependentVector.definition; let needsUpdate = false; let operandValues = []; if (opInfo.operands.includes(changedVectorId)) { needsUpdate = true; operandValues = opInfo.operands.map(id => findVectorById(id)); if (operandValues.some(v => v === null)) { console.warn(`Operand missing for ${dependentVector.name}. Converting to base.`); dependentVector.definition = { type: 'base' }; dependentVector.isResult = false; needsUpdate = false; } } if (needsUpdate) { console.log(`Recalculating ${dependentVector.name} based on ${changedVectorId}`); let newDirection = new THREE.Vector3(); let calculationSuccess = true; try { switch (opInfo.op) { case 'add': newDirection.addVectors(operandValues[0].direction, operandValues[1].direction); break; case 'sub': newDirection.subVectors(operandValues[0].direction, operandValues[1].direction); break; case 'cross': newDirection.crossVectors(operandValues[0].direction, operandValues[1].direction); break; case 'scalar_mult': const scalar = opInfo.scalar ?? 1; newDirection.copy(operandValues[0].direction).multiplyScalar(scalar); break; case 'projection': const vecA = operandValues[0].direction; const vecB = operandValues[1].direction; const lenBSq = vecB.lengthSq(); if (lenBSq > 1e-10) { const dotProduct = vecA.dot(vecB); const scalarProjection = dotProduct / lenBSq; newDirection.copy(vecB).multiplyScalar(scalarProjection); } else { newDirection.set(0, 0, 0); } break; default: console.error("Unknown operation type:", opInfo.op); calculationSuccess = false; } } catch (error) { console.error(`Error recalculating ${dependentVector.name}:`, error); calculationSuccess = false; dependentVector.definition = { type: 'base' }; dependentVector.isResult = false; } if (calculationSuccess) { const updateOk = updateVectorProperties(dependentVector, newDirection); if (updateOk) { updateDependentVectors(dependentVector.id, visited); } } } } }); }

// --- Delete ---
function updateVectorListUI() { vectorListDiv.innerHTML = '<h3 class="text-md font-semibold mb-1">Vectors</h3>'; opVectorASelect.innerHTML = ''; opVectorBSelect.innerHTML = ''; scalarVectorSelect.innerHTML = ''; const editIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg>`; const trashIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" /></svg>`; if (vectors.length === 0) { vectorListDiv.innerHTML += '<p class="text-gray-400 text-sm p-2">No vectors added yet.</p>'; const placeholderOption = '<option value="" disabled>No vectors</option>'; opVectorASelect.innerHTML = placeholderOption; opVectorBSelect.innerHTML = placeholderOption; scalarVectorSelect.innerHTML = placeholderOption; } else { vectors.forEach(vec => { const div = document.createElement('div'); div.className = 'vector-list-item'; const vecCoords = `(${vec.direction.x.toFixed(1)}, ${vec.direction.y.toFixed(1)}, ${vec.direction.z.toFixed(1)})`; let dependencyInfo = ''; if (vec.definition?.type === 'operation') { const op = vec.definition.op; const operandNames = vec.definition.operands.map(id => findVectorById(id)?.name || '?'); if (op === 'scalar_mult') { dependencyInfo = `(${vec.definition.scalar} * ${operandNames[0]})`; } else if (op === 'projection') { dependencyInfo = `(Proj_${operandNames[1]}(${operandNames[0]}))`; } else { dependencyInfo = `(${operandNames[0]} ${opSymbol(op)} ${operandNames[1]})`; } } const isEditable = vec.definition?.type === 'base'; const editButtonHtml = `<button data-id="${vec.id}" class="vector-action-btn edit-vector-btn ${!isEditable ? 'opacity-50 cursor-not-allowed' : ''}" title="${isEditable ? 'Edit Vector' : 'Cannot edit dependent vector'}" ${!isEditable ? 'disabled' : ''}>${editIconSVG}</button>`; div.innerHTML = `<span class="vector-item-details"><span class="vector-color-swatch" style="background-color:${vec.color};"></span><span class="font-semibold mr-1">${vec.name}:</span><span class="vector-coords">${vecCoords}</span><span class="vector-dependency-info">${dependencyInfo}</span></span><span class="vector-actions">${editButtonHtml}<button data-id="${vec.id}" class="vector-action-btn remove-vector-btn" title="Remove Vector">${trashIconSVG}</button></span>`; if (isEditable) { div.querySelector('.edit-vector-btn').addEventListener('click', () => startEditVector(vec.id)); } div.querySelector('.remove-vector-btn').addEventListener('click', () => removeVectorById(vec.id)); vectorListDiv.appendChild(div); const option = document.createElement('option'); option.value = vec.id; option.textContent = `${vec.name} ${vecCoords}`; opVectorASelect.appendChild(option.cloneNode(true)); opVectorBSelect.appendChild(option.cloneNode(true)); scalarVectorSelect.appendChild(option.cloneNode(true)); }); if (opVectorBSelect.options.length > 1) { opVectorBSelect.selectedIndex = 1; } } updateMagnitudeAngleDisplay(); updateOperationButtonStates(); }
function updateMagnitudeAngleDisplay() { const vecAData = getSelectedVectorData('opVectorA'); const vecBData = getSelectedVectorData('opVectorB'); if (vecAData) { magnitudeADisplay.textContent = vecAData.direction.length().toFixed(3); } else { magnitudeADisplay.textContent = "-"; } if (vecBData) { magnitudeBDisplay.textContent = vecBData.direction.length().toFixed(3); } else { magnitudeBDisplay.textContent = "-"; } if (vecAData && vecBData) { const lenA = vecAData.direction.lengthSq(); const lenB = vecBData.direction.lengthSq(); if (lenA < 1e-10 || lenB < 1e-10) { angleABDisplay.textContent = "N/A (Zero Vector)"; } else { const angleRad = vecAData.direction.angleTo(vecBData.direction); const angleDeg = angleRad * (180 / Math.PI); angleABDisplay.textContent = `${angleDeg.toFixed(1)}°`; } } else { angleABDisplay.textContent = "-"; } }
function opSymbol(opName) { switch(opName) { case 'add': return '+'; case 'sub': return '-'; case 'cross': return 'x'; default: return '?'; } }
function updateOperationButtonStates() { const vecCount = vectors.length; addBtn.disabled = vecCount < 2; subBtn.disabled = vecCount < 2; dotBtn.disabled = vecCount < 2; crossBtn.disabled = vecCount < 2; scalarMultBtn.disabled = vecCount < 1; projBtn.disabled = vecCount < 2; }
function disposeVectorAssets(vectorData) { if (!vectorData) return; const arrow = vectorData.arrow; if (arrow) { if (arrow.line && arrow.line.geometry) arrow.line.geometry.dispose(); if (arrow.line && arrow.line.material) arrow.line.material.dispose(); if (arrow.cone && arrow.cone.geometry) arrow.cone.geometry.dispose(); if (arrow.cone && arrow.cone.material) arrow.cone.material.dispose(); } const handle = vectorData.dragHandle; if (handle) { if (handle.geometry) handle.geometry.dispose(); if (handle.material) handle.material.dispose(); } }
function removeVectorById(id) { const indexToRemove = vectors.findIndex(vec => vec.id === id); if (indexToRemove !== -1) { const vectorToRemove = vectors[indexToRemove]; const removedName = vectorToRemove.name; const dependentsToConvert = []; vectors.forEach(v => { if (v.definition?.type === 'operation' && v.definition.operands.includes(id)) { dependentsToConvert.push(v); } }); dependentsToConvert.forEach(dep => { console.log(`Converting ${dep.name} to base vector because ${removedName} was deleted.`); dep.definition = { type: 'base' }; dep.isResult = false; showResult(`Vector ${dep.name} is now a base vector (dependency ${removedName} removed).`, "warning"); }); const handleIndex = draggableObjects.indexOf(vectorToRemove.dragHandle); if (handleIndex > -1) { draggableObjects.splice(handleIndex, 1); } else { console.warn("Drag handle not found in draggableObjects for vector:", removedName); } scene.remove(vectorToRemove.arrow); scene.remove(vectorToRemove.dragHandle); disposeVectorAssets(vectorToRemove); vectors.splice(indexToRemove, 1); updateVectorListUI(); showResult(`Removed vector ${removedName}.`, "info"); console.log("Removed vector with ID:", id); if (parseFloat(editingVectorIdInput.value) === id) { cancelEditMode(); } } else { console.warn("Could not find vector ID to remove:", id); } }
function getSelectedVectorData(selectElementId) { const selectElement = document.getElementById(selectElementId); const selectedId = parseFloat(selectElement.value); if (isNaN(selectedId)) return null; return vectors.find(vec => vec.id === selectedId) || null; }
function showResult(message, type = 'info') { operationResultDiv.textContent = message; operationResultDiv.className = `result-${type} mt-4 p-2 bg-gray-700 rounded min-h-[30px] text-sm word-wrap`; }
function startEditVector(id) { const vectorData = vectors.find(vec => vec.id === id); if (!vectorData || vectorData.definition?.type !== 'base') { console.error("Cannot edit: Vector not found or is dependent.", id); showResult("Error: Cannot edit dependent vectors via form.", "error"); return; } console.log("Starting edit for vector ID:", id, vectorData.name); vectorFormTitle.textContent = `Edit Vector ${vectorData.name}`; editingVectorIdInput.value = id; vecXInput.value = vectorData.direction.x.toFixed(3); vecYInput.value = vectorData.direction.y.toFixed(3); vecZInput.value = vectorData.direction.z.toFixed(3); vecColorInput.value = vectorData.color; addUpdateBtn.textContent = 'Update Vector'; cancelEditBtn.classList.remove('hidden'); showResult(`Editing base vector ${vectorData.name}. Modify values or drag arrowhead.`, "info"); }
function cancelEditMode() { vectorFormTitle.textContent = 'Add Vector'; editingVectorIdInput.value = ''; resetVectorForm(); addUpdateBtn.textContent = 'Add Vector'; cancelEditBtn.classList.add('hidden'); }
function resetVectorForm() { vecXInput.value = '1'; vecYInput.value = '1'; vecZInput.value = '1'; vecColorInput.value = '#ff0000'; }
function onDragStart(event) { const handle = event.object; console.log("Drag Start Handle for:", handle.userData.vectorId); orbitControls.enabled = false; handle.material.opacity = 0.5; renderer.domElement.classList.add('dragging'); }
function onDrag(event) { const draggedHandle = event.object; const vectorId = draggedHandle.userData.vectorId; if (vectorId === undefined) return; const vectorData = findVectorById(vectorId); if (!vectorData) return; if (vectorData.definition.type !== 'base') { console.log(`Vector ${vectorData.name} converted to base vector due to drag.`); vectorData.definition = { type: 'base' }; vectorData.isResult = false; } const newDirection = draggedHandle.position; const updateSuccess = updateVectorProperties(vectorData, newDirection); if (updateSuccess) { updateDependentVectors(vectorId, new Set()); const listItem = vectorListDiv.querySelector(`button[data-id="${vectorId}"]`)?.closest('.vector-list-item'); if (listItem) { const coordsSpan = listItem.querySelector('.vector-coords'); if (coordsSpan) { coordsSpan.textContent = `(${newDirection.x.toFixed(1)}, ${newDirection.y.toFixed(1)}, ${newDirection.z.toFixed(1)})`; } const optionText = `${vectorData.name} (${newDirection.x.toFixed(1)}, ${newDirection.y.toFixed(1)}, ${newDirection.z.toFixed(1)})`; [opVectorASelect, opVectorBSelect, scalarVectorSelect].forEach(select => { const option = select.querySelector(`option[value="${vectorId}"]`); if (option) option.textContent = optionText; }); } if (parseFloat(editingVectorIdInput.value) === vectorId) { vecXInput.value = newDirection.x.toFixed(3); vecYInput.value = newDirection.y.toFixed(3); vecZInput.value = newDirection.z.toFixed(3); } } }
function onDragEnd(event) { const handle = event.object; const vectorId = handle.userData.vectorId; console.log("Drag End Handle for:", vectorId); orbitControls.enabled = true; handle.material.opacity = 0.0; renderer.domElement.classList.remove('dragging'); if (vectorId === undefined) return; const vectorData = findVectorById(vectorId); if (!vectorData) return; updateVectorListUI(); showResult(`Vector ${vectorData.name} updated via drag.`, "info"); }
function onHoverOn(event) { renderer.domElement.classList.add('draggable-hover'); } function onHoverOff(event) { renderer.domElement.classList.remove('draggable-hover'); }

// --- Vector Operations ---
function performVectorAddition() { const vecAData = getSelectedVectorData('opVectorA'); const vecBData = getSelectedVectorData('opVectorB'); if (!vecAData || !vecBData) { showResult("Error: Select two vectors.", "error"); return; } const resultVec = new THREE.Vector3().addVectors(vecAData.direction, vecBData.direction); const resultName = generateVectorName(`${vecAData.name}+${vecBData.name}`, vectors.map(v => v.name)); const definition = { type: 'operation', op: 'add', operands: [vecAData.id, vecBData.id] }; const newVecData = addVectorToScene(new THREE.Vector3(0,0,0), resultVec, '#FFFFFF', resultName, definition, false, null, true); if (newVecData) showResult(`Add: ${resultName} = (${resultVec.x.toFixed(2)}, ${resultVec.y.toFixed(2)}, ${resultVec.z.toFixed(2)})`, "success"); }
function performVectorSubtraction() { const vecAData = getSelectedVectorData('opVectorA'); const vecBData = getSelectedVectorData('opVectorB'); if (!vecAData || !vecBData) { showResult("Error: Select two vectors.", "error"); return; } const resultVec = new THREE.Vector3().subVectors(vecAData.direction, vecBData.direction); const resultName = generateVectorName(`${vecAData.name}-${vecBData.name}`, vectors.map(v => v.name)); const definition = { type: 'operation', op: 'sub', operands: [vecAData.id, vecBData.id] }; const newVecData = addVectorToScene(new THREE.Vector3(0,0,0), resultVec, '#FFFF00', resultName, definition, false, null, true); if (newVecData) showResult(`Sub: ${resultName} = (${resultVec.x.toFixed(2)}, ${resultVec.y.toFixed(2)}, ${resultVec.z.toFixed(2)})`, "success"); }
function performScalarMultiplication() { const vecData = getSelectedVectorData('scalarVector'); const scalar = parseFloat(scalarValueInput.value); if (!vecData) { showResult("Error: Select a vector.", "error"); return; } if (isNaN(scalar)) { showResult("Error: Invalid scalar.", "error"); return; } const resultVec = vecData.direction.clone().multiplyScalar(scalar); const resultName = generateVectorName(`${scalar}*${vecData.name}`, vectors.map(v => v.name)); const definition = { type: 'operation', op: 'scalar_mult', operands: [vecData.id], scalar: scalar }; const newVecData = addVectorToScene(new THREE.Vector3(0,0,0), resultVec, '#00FFFF', resultName, definition, false, null, true); if (newVecData) showResult(`Scalar Mult: ${resultName} = (${resultVec.x.toFixed(2)}, ${resultVec.y.toFixed(2)}, ${resultVec.z.toFixed(2)})`, "success"); }
function performDotProduct() { const vecAData = getSelectedVectorData('opVectorA'); const vecBData = getSelectedVectorData('opVectorB'); if (!vecAData || !vecBData) { showResult("Error: Select two vectors.", "error"); return; } const dotProduct = vecAData.direction.dot(vecBData.direction); showResult(`Dot Product (${vecAData.name} · ${vecBData.name}) = ${dotProduct.toFixed(3)}`, "info"); }
function performCrossProduct() { const vecAData = getSelectedVectorData('opVectorA'); const vecBData = getSelectedVectorData('opVectorB'); if (!vecAData || !vecBData) { showResult("Error: Select two vectors.", "error"); return; } const resultVec = new THREE.Vector3().crossVectors(vecAData.direction, vecBData.direction); const resultName = generateVectorName(`${vecAData.name}x${vecBData.name}`, vectors.map(v => v.name)); if (resultVec.lengthSq() < 1e-10) { showResult(`Cross Product (${vecAData.name} x ${vecBData.name}) = 0 (Vectors parallel)`, "warning"); } else { const definition = { type: 'operation', op: 'cross', operands: [vecAData.id, vecBData.id] }; const newVecData = addVectorToScene(new THREE.Vector3(0,0,0), resultVec, '#FF00FF', resultName, definition, false, null, true); if (newVecData) showResult(`Cross Product: ${resultName} = (${resultVec.x.toFixed(2)}, ${resultVec.y.toFixed(2)}, ${resultVec.z.toFixed(2)})`, "success"); } }
function performProjection() { const vecAData = getSelectedVectorData('opVectorA'); const vecBData = getSelectedVectorData('opVectorB'); if (!vecAData || !vecBData) { showResult("Error: Select two vectors for projection.", "error"); return; } const vecA = vecAData.direction; const vecB = vecBData.direction; const lenBSq = vecB.lengthSq(); let projectionVector = new THREE.Vector3(); if (lenBSq > 1e-10) { const dotProduct = vecA.dot(vecB); const scalarProjection = dotProduct / lenBSq; projectionVector.copy(vecB).multiplyScalar(scalarProjection); } else { showResult(`Cannot project onto zero vector (${vecBData.name}). Result is zero vector.`, "warning"); } const resultName = generateVectorName(`Proj_${vecBData.name}(${vecAData.name})`, vectors.map(v => v.name)); const definition = { type: 'operation', op: 'projection', operands: [vecAData.id, vecBData.id] }; const newVecData = addVectorToScene( new THREE.Vector3(0, 0, 0), projectionVector, PROJECTION_COLOR, resultName, definition, false, null, true ); if (newVecData) { showResult(`Projection ${resultName} = (${projectionVector.x.toFixed(2)}, ${projectionVector.y.toFixed(2)}, ${projectionVector.z.toFixed(2)})`, "success"); } else if (lenBSq <= 1e-10) { } else { showResult(`Projection ${resultName} resulted in a zero vector.`, "info"); } }

// --- Import/Export Functions --
function clearScene() { while (vectors.length > 0) { const vectorData = vectors.pop(); if (vectorData.arrow) scene.remove(vectorData.arrow); if (vectorData.dragHandle) scene.remove(vectorData.dragHandle); disposeVectorAssets(vectorData); } draggableObjects.length = 0; updateVectorListUI(); showResult("Scene cleared.", "info"); }
function prepareDataForExport() { return vectors.map(vec => ({ id: vec.id, name: vec.name, color: vec.color, origin: { x: vec.origin.x, y: vec.origin.y, z: vec.origin.z }, direction: { x: vec.direction.x, y: vec.direction.y, z: vec.direction.z }, definition: vec.definition })); }
function exportScene() { try { const exportData = prepareDataForExport(); if (exportData.length === 0) { showResult("Scene is empty, nothing to export.", "warning"); return; } const jsonString = JSON.stringify(exportData, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'vector_scene.json'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); showResult("Scene exported successfully.", "success"); } catch (error) { console.error("Error exporting scene:", error); showResult("Error exporting scene. See console for details.", "error"); } }
function importScene(event) { const file = event.target.files[0]; if (!file) { showResult("No file selected for import.", "info"); return; } const reader = new FileReader(); reader.onload = (e) => { try { const importedData = JSON.parse(e.target.result); if (!Array.isArray(importedData)) { throw new Error("Invalid file format: Expected an array of vectors."); } clearScene(); let importCount = 0; importedData.forEach(vecData => { if (vecData && typeof vecData.direction === 'object' && typeof vecData.definition === 'object') { const origin = new THREE.Vector3(vecData.origin?.x || 0, vecData.origin?.y || 0, vecData.origin?.z || 0); const direction = new THREE.Vector3(vecData.direction.x || 0, vecData.direction.y || 0, vecData.direction.z || 0); const color = vecData.color || '#ffffff'; const name = vecData.name || 'ImportedVector'; const definition = vecData.definition; const id = vecData.id; addVectorToScene(origin, direction, color, name, definition, false, id, false); importCount++; } else { console.warn("Skipping invalid vector data during import:", vecData); } }); updateVectorListUI();  showResult(`Successfully imported ${importCount} vectors.`, "success"); } catch (error) { console.error("Error importing scene:", error); showResult(`Error importing scene: ${error.message}`, "error"); clearScene(); } finally { importFileInput.value = null; } }; reader.onerror = (e) => { console.error("Error reading file:", e); showResult("Error reading import file.", "error"); importFileInput.value = null; }; reader.readAsText(file); }

// --- Event Handlers ---
function onWindowResize() {  camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
function animate() {  requestAnimationFrame(animate); orbitControls.update(); renderer.render(scene, camera); }

init();